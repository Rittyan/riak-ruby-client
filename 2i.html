<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<title>Secondary Indexes</title>
<link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
<script src="javascripts/all.js" type="text/javascript"></script>
</head>
<body class='x2i'>
<header>
<nav>
<ul>
<li class='title'>riak-ruby-client</li>
<li><a href="./">Home</a></li>
<li><a href="kv.html">Key-Value</a></li>
<li><a href="yz.html">Search</a></li>
<li><a href="2i.html">Secondary Indexes</a></li>
<li><a href="crdt.html">CRDTs</a></li>
<li><a href="bucket_types.html">Bucket Types</a></li>
<li><a href="bucket_props.html">Bucket Properties</a></li>
<li><a href="rspecs.html">Testing</a></li>
<li class='space'><a href="install.html">Installation</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="https://github.com/basho/riak-ruby-client">Source</a></li>
<li><a href="https://rubygems.org/gems/riak-client">Gem</a></li>
</ul>
</nav>

</header>
<div class='content'>
<h1 class='title'>Secondary Indexes</h1>
<div id='toc'></div>
<div id='yielded'><p>Secondary indexes, commonly called &ldquo;2i,&rdquo; are a way to add and query specific
tags on objects. It requires the <code>memory</code> or <code>leveldb</code> backend. It will work
with the <code>multi</code> backend configured to use <code>memory</code> or <code>leveldb</code> for your
specific objects.</p>

<p>Check out the Riak docuentation on <a href="kv.html#toc-content-and-conflict">using secondary indexes</a> and a few
<a href="http://docs.basho.com/riak/latest/dev/advanced/2i/">notes about 2i implementation</a>.</p>

<h2>tl;dr</h2>

<p>Tagging and simple querying:</p>
<pre class="highlight ruby"><code><span class="c1"># #indexes is a hash of arrays</span>
<span class="c1"># keys are postfixed with _bin for binary/string indexes, _int for integers</span>
<span class="c1"># values are arrays</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'ingredients_bin'</span><span class="p">]</span> <span class="o">=</span> <span class="sx">%w{lettuce tomato bacon egg chives}</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'calories_int'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">220</span><span class="p">]</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">store</span>

<span class="c1"># integer indexes can be queried for match or range</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="mi">220</span> <span class="c1">#=&gt; ['cobb_salad']</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="nf">.</span><span class="mi">300</span><span class="p">)</span> <span class="c1">#=&gt; ['cobb_salad']</span>

<span class="c1"># bin indexes can be queried for match or range too</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'lettuce'</span> <span class="c1">#=&gt; ['cobb_salad']</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'tomata'</span><span class="p">.</span><span class="nf">.</span><span class="s1">'tomatz'</span> <span class="c1">#=&gt; ['cobb_salad']</span>
</code></pre>

<p>Paginated queries:</p>
<pre class="highlight ruby"><code><span class="n">page_1</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'lettuce'</span><span class="p">,</span> <span class="ss">max_results: </span><span class="mi">5</span>
<span class="n">page_1</span><span class="p">.</span><span class="nf">length</span> <span class="c1">#=&gt; 5</span>
<span class="n">page_1</span><span class="p">.</span><span class="nf">continuation</span> <span class="c1">#=&gt; "g2gCbQAAA="</span>

<span class="n">page_2</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span><span class="p">(</span><span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'lettuce'</span><span class="p">,</span>
                      <span class="ss">max_results: </span><span class="mi">5</span><span class="p">,</span>
                      <span class="ss">continuation: </span><span class="n">page_1</span><span class="p">.</span><span class="nf">continuation</span><span class="p">)</span>
</code></pre>

<h2>Tagging</h2>

<p>Each <code>RObject</code> has an <code>indexes</code> accessor that&rsquo;s a Hash of <code>String</code> keys to
<code>Set</code> values. Keys must end with an underscore and the type of index they are:
<code>_bin</code> for binary/<code>String</code> indexes, or <code>_int</code> for <code>Integer</code> indexes. The values
must be a set of the appropriate index members. One object can have multiple
keys in the same index.</p>

<p>Indexes are not saved until the entire object is stored.</p>
<pre class="highlight ruby"><code><span class="c1"># allow finding this salad by any of its ingredients</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'ingredients_bin'</span><span class="p">]</span> <span class="o">=</span> <span class="sx">%w{lettuce tomato bacon egg chives}</span>

<span class="c1"># allow finding this salad by how many calories it has per serving</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'calories_int'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">220</span><span class="p">]</span>

<span class="c1"># actually store the indexes</span>
<span class="n">cobb_salad</span><span class="p">.</span><span class="nf">store</span>
</code></pre>

<h3>Tagging and Conflict Resolution</h3>

<p>The <code>indexes</code> hash is actually on the <code>RContent</code> object. You can merge or
otherwise process conflicting indexes during <a href="kv.html#toc-content-and-conflict">conflict resolution:</a></p>
<pre class="highlight ruby"><code><span class="k">if</span> <span class="n">salad</span><span class="p">.</span><span class="nf">conflict?</span>
  <span class="n">salad</span><span class="p">.</span><span class="nf">siblings</span><span class="p">.</span><span class="nf">inject</span> <span class="k">do</span> <span class="o">|</span><span class="n">merged_salad</span><span class="p">,</span> <span class="n">current_salad</span><span class="o">|</span>
    <span class="c1"># merging the salad data is left as an exercise for the reader</span>

    <span class="n">merged_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'ingredients_bin'</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">merged_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'ingredients_bin'</span><span class="p">]</span> <span class="o">+</span>
      <span class="n">current_salad</span><span class="p">.</span><span class="nf">indexes</span><span class="p">[</span><span class="s1">'ingredients_bin'</span><span class="p">]</span>
      <span class="p">).</span><span class="nf">uniq</span>

    <span class="k">next</span> <span class="n">merged_salad</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<h2>Querying</h2>

<p>There are two different Ruby client APIs for querying secondary indexes: directly
on the bucket, or through a <code>SecondaryIndex</code> object. These use the same Riak
server API, they just provide different levels of convenience based on how
complex your needs are.</p>

<h3>Querying on the Bucket</h3>

<p>Use the <code>Bucket#get_index</code> method for straightforward 2i queries. It returns a
<code>Riak::IndexCollection</code> instance, which is a subclass of <code>Array</code> with a few
extra accessors and methods for results.</p>

<p>You can query for a scalar or a range, of either integers or strings:</p>
<pre class="highlight ruby"><code><span class="n">c</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="mi">220</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="mi">200</span><span class="p">.</span><span class="nf">.</span><span class="mi">240</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'tomato'</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_index</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'tomata'</span><span class="p">.</span><span class="nf">.</span><span class="s1">'tomatz'</span>
</code></pre>

<p><code>Bucket#get_index</code> takes other options too:</p>

<ul>
<li><code>max_results</code>: controls how many results Riak will return</li>
<li><code>continuation</code>: returned from a paginated query to allow access to consecutive
pages</li>
<li><code>return_terms</code>: include matched index terms in the <code>IndexCollection</code> results</li>
</ul>

<h3>Querying with a <code>SecondaryIndex</code> object</h3>

<p>The <code>Riak::SecondaryIndex</code> object is constructed with:</p>

<ul>
<li><code>Bucket</code> instance</li>
<li>index name (i.e. <code>ingredients_bin</code>)</li>
<li>query (scalar or range)</li>
<li>options hash (optional)</li>
</ul>
<pre class="highlight ruby"><code><span class="n">q</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">SecondaryIndex</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="mi">220</span>
<span class="n">q</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">SecondaryIndex</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'calories_int'</span><span class="p">,</span> <span class="mi">200</span><span class="p">.</span><span class="nf">.</span><span class="mi">240</span>

<span class="n">q</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">SecondaryIndex</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'tomato'</span>
<span class="n">q</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">SecondaryIndex</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'ingredients_bin'</span><span class="p">,</span> <span class="s1">'tomata'</span><span class="p">.</span><span class="nf">.</span><span class="s1">'tomatz'</span>
</code></pre>

<p>Just like <code>Bucket#get_index</code>, <code>Riak::SecondaryIndex.new</code> takes options:</p>

<ul>
<li><code>max_results</code>: control how many results are returned from Riak</li>
<li><code>continuation</code>: opaque string that provides access to additional pages of
results</li>
<li><code>return_terms</code>: return a hash of keys to terms they matched</li>
</ul>

<p>Queries are lazy: they&rsquo;re not sent to the server until absolutely necessary.</p>

<h4>Getting a Collection of Keys or Values</h4>

<p>Simply ask a <code>SecondaryIndex</code> instance for keys and it will return an
<code>IndexCollection</code>:</p>
<pre class="highlight ruby"><code><span class="n">q</span><span class="p">.</span><span class="nf">keys</span> <span class="c1">#=&gt; an IndexCollection</span>
</code></pre>

<p>The collection is memoized; the first time it&rsquo;s requested will round-trip to
Riak, after that it&rsquo;s cached.</p>

<p>If you want to materialize those keys into values, invoking the <code>#values</code>
method will perform a multi-threaded multi-get to load them for you:</p>
<pre class="highlight ruby"><code><span class="n">q</span><span class="p">.</span><span class="nf">values</span> <span class="c1">#=&gt; an Array of RObjects</span>
</code></pre>

<h4>Streaming Keys</h4>

<p>Performing a large enough query can take some time. The Riak node handling the
query has to sort and collate the results before sending them over the wire en
masse. Performing a streaming query obviates this: the Riak node will return
chunks of results as they become available.</p>

<p>Pass a block to the <code>keys</code> method during its first invocation to perform a
streaming query:</p>
<pre class="highlight ruby"><code><span class="n">q</span><span class="p">.</span><span class="nf">keys</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"The key is </span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre>

<h4>Pagination</h4>

<p>When a next page is available, calling the <code>next_page</code> method on a
<code>SecondaryIndex</code> instance will return a new instance for the next page.</p>
<pre class="highlight ruby"><code><span class="n">page_1</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">SecondaryIndex</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span>
                                  <span class="s1">'ingredients_bin'</span><span class="p">,</span>
                                  <span class="s1">'lettuce'</span><span class="p">,</span>
                                  <span class="ss">max_results: </span><span class="mi">5</span><span class="p">)</span>
<span class="n">page_2</span> <span class="o">=</span> <span class="n">page_1</span><span class="p">.</span><span class="nf">next_page</span>
<span class="n">page_3</span> <span class="o">=</span> <span class="n">page_2</span><span class="p">.</span><span class="nf">next_page</span>
</code></pre>

<p>When a next page is not available, calling the <code>next_page</code> method rasises an
error.</p>

<h2>The <code>IndexCollection</code> Class</h2>

<p><code>Bucket#get_index</code> and <code>Riak::SecondaryIndex#keys</code> both return <code>IndexCollection</code>
instances. These are simply <code>Array</code>s of keys with a few extra methods.</p>

<ul>
<li><code>continuation</code>: an opaque <code>String</code> used for pagination. If it&rsquo;s not present,
there is no next page.</li>
<li><code>with_terms</code>: a <code>Hash</code> of keys to the index value they matched against. This
can be used with a range query to materialize a bit of result without
requiring a full key load.</li>
</ul>
</div>
</div>
<footer>
Documentation generated at 2015-02-10 20:10:04 UTC from repo version 8aa03d0d1ba72c3037119d6636c6487123d54ce2.
</footer>
</body>
</html>
