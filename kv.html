<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<title>Key-Value</title>
<link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
<script src="javascripts/all.js" type="text/javascript"></script>
</head>
<body class='kv'>
<header>
<nav>
<ul>
<li class='title'>riak-ruby-client</li>
<li><a href="./">Home</a></li>
<li><a href="kv.html">Key-Value</a></li>
<li><a href="yz.html">Search</a></li>
<li><a href="2i.html">Secondary Indexes</a></li>
<li><a href="crdt.html">CRDTs</a></li>
<li><a href="bucket_types.html">Bucket Types</a></li>
<li><a href="bucket_props.html">Bucket Properties</a></li>
<li><a href="rspecs.html">Testing</a></li>
<li class='space'><a href="install.html">Installation</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="https://github.com/basho/riak-ruby-client">Source</a></li>
<li><a href="https://rubygems.org/gems/riak-client">Gem</a></li>
</ul>
</nav>

</header>
<div class='content'>
<h1 class='title'>Key-Value</h1>
<div id='toc'></div>
<div id='yielded'><p>Key-value operations in Riak use a few different kinds of object:</p>

<ul>
<li>A <strong>bucket type</strong> is a set of configration information used to read and write
values in Riak. Bucket types are complex and can be unintuitive, so
<a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">please read the bucket type documentation</a>.</li>
<li>A <strong>bucket</strong> is a named collection of keys. It&rsquo;s similar to a table in a SQL
database: it has a name that&rsquo;s a string, zero or more members, and members
can be quickly looked up by their key (primary key in SQL).</li>
<li>A <strong>key</strong> is a unique string name for something in a bucket. Think of them
like a SQL primary key that&rsquo;s a string.</li>
<li>A <strong>value</strong> is a large binary object that is addressed by a bucket type,
bucket, and key. It works similarly to a BLOB column in SQL. Riak objects
can have more than one value, which requires conflict resolution.</li>
</ul>

<p>For more about buckets, keys, and values, read the <a href="crdt.html">object/key operations</a>
documentation.</p>

<h2>tl;dr</h2>

<p>Get an object:</p>
<pre class="highlight ruby"><code><span class="c1"># get a bucket</span>
<span class="n">bucket</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">bucket</span> <span class="s1">'pages'</span>

<span class="c1"># â€¦or get a bucket-typed bucket</span>
<span class="n">type</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">bucket_type</span> <span class="s1">'my_cool_type'</span>
<span class="n">bucket</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="nf">bucket</span> <span class="s1">'pages'</span>

<span class="c1"># get an object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'index.html'</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="s1">'index.html'</span><span class="p">]</span>

<span class="c1"># get or create an object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_or_new</span> <span class="s1">'index.html'</span>

<span class="c1"># create a new object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'index.html'</span>

<span class="c1"># change the object's data and save</span>
<span class="n">object</span><span class="p">.</span><span class="nf">raw_data</span> <span class="o">=</span> <span class="s2">"&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;"</span>
<span class="n">object</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s2">"text/html"</span>
<span class="n">object</span><span class="p">.</span><span class="nf">store</span>

<span class="c1"># reload an object you already have the vclock of</span>
<span class="n">object</span><span class="p">.</span><span class="nf">reload</span>

<span class="c1"># reload an object without the vclock</span>
<span class="n">object</span><span class="p">.</span><span class="nf">reload</span> <span class="ss">:force</span> <span class="o">=&gt;</span> <span class="kp">true</span>

<span class="c1"># delete an object</span>
<span class="n">object</span><span class="p">.</span><span class="nf">delete</span>
</code></pre>

<h2>Objects</h2>

<p>Riak&rsquo;s key-value interface maniuplates objects. You can think of an object as
a tuple:</p>
<pre class="highlight ruby"><code>  <span class="p">{</span><span class="n">bucket</span> <span class="n">type</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">values</span><span class="p">}</span>
</code></pre>

<p>A bucket type and bucket identify a collection of objects, and the set of
bucket type, bucket, and key identify a single object.</p>

<p>In the Ruby client, a Riak object is represented by a <code>Riak::RObject</code> instance.</p>
<pre class="highlight ruby"><code><span class="n">robject</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="s1">'S. S. Boatname'</span><span class="p">]</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">class</span> <span class="c1">#=&gt; Riak::RObject</span>
</code></pre>

<h3>Creating Objects</h3>

<p>You have a few choices when insantiating an object.</p>

<p>Given a bucket, you can use the <code>RObject</code> constructor to create a new object:</p>
<pre class="highlight ruby"><code><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'Son of Boatname'</span>
</code></pre>

<p>If you use the <code>Bucket#new</code> method, the <code>RObject</code> is created with a
<code>content_type</code> of <code>application/json</code> for you:</p>
<pre class="highlight ruby"><code><span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'Son of Boatname'</span>
</code></pre>

<p>If you want Riak to pick a key for an object for you, create one without
specifying a key:</p>
<pre class="highlight ruby"><code><span class="c1"># these both work</span>
<span class="n">robject</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="kp">nil</span>
<span class="n">robject</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">key</span> <span class="c1">#=&gt; "GB8fW6DDZtXogK19OLmaJf247DN"</span>
</code></pre>

<h3>Loading Objects</h3>

<p>You can load an object if you know its key. If loading the object fails, this
will raise a <code>Riak::FailedRequest</code> error with the <code>not_found?</code> flag set.</p>
<pre class="highlight ruby"><code><span class="n">bucket</span><span class="p">[</span><span class="s1">'S. S. Boatname'</span><span class="p">]</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'S. S. Boatname'</span>
</code></pre>

<p>If you want to load or create an object with a given key, you can use
<code>Bucket#get_or_new</code> to do it:</p>
<pre class="highlight ruby"><code><span class="n">bucket</span><span class="p">.</span><span class="nf">get_or_new</span> <span class="s1">'Revenge of Boatname'</span>
</code></pre>

<h4>Loading Many Objects</h4>

<p>Sometimes, you need to load a lot of objects in preparation for aggregation or
another operation. The multi-get functionality allows you to use a nested
<code>Array</code> of <code>[Bucket, String&lt;key&gt;]</code> identifiers (&ldquo;pairs&rdquo;) to load objects using
multiple worker threads.</p>

<p>The array of pairs should be structured like this:</p>
<pre class="highlight ruby"><code><span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="n">bucket</span><span class="p">,</span> <span class="s1">'S. S. Boatname'</span><span class="p">],</span>
    <span class="p">[</span><span class="n">bucket</span><span class="p">,</span> <span class="s1">'Son of Boatname'</span><span class="p">],</span>
    <span class="p">[</span><span class="n">bucket</span><span class="p">,</span> <span class="s1">'Revenge of Boatname'</span><span class="p">],</span>
<span class="p">]</span>
</code></pre>

<p>The <code>Riak::Client#get_many</code> and <code>Riak::Multiget.get_all</code> class
methods simply return the hash of pair to <code>RObject</code> instances:</p>
<pre class="highlight ruby"><code><span class="c1"># equivalent</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">get_many</span> <span class="n">pairs</span>
<span class="n">results</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">Multiget</span><span class="p">.</span><span class="nf">get_all</span> <span class="n">client</span><span class="p">,</span> <span class="n">pairs</span>
</code></pre>

<p>If you want to kick off a multiget operation and perform some other operations
while it proceeds, use an instance of the <code>Riak::Multiget</code> class.</p>
<pre class="highlight ruby"><code><span class="n">mg</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">Multiget</span><span class="p">.</span><span class="nf">new</span> <span class="n">client</span><span class="p">,</span> <span class="n">pairs</span>
<span class="n">mg</span><span class="p">.</span><span class="nf">fetch</span>
<span class="nb">puts</span> <span class="s2">"Loading... Please wait..."</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">mg</span><span class="p">.</span><span class="nf">results</span>
</code></pre>

<h3>Manipulating and Storing Objects</h3>

<h4>Raw Data, No Serialization</h4>

<p>Use the <code>RObject#raw_data</code> accessors to manipulate the raw blob/string that
represents the value of a Riak object. The client will not transform or parse
this data.</p>
<pre class="highlight ruby"><code><span class="n">robject</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s1">'image/jpeg'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span> <span class="s1">'cat.jpg'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>
</code></pre>

<h4>Serializing and Deserializing Data</h4>

<p>Frequently, you&rsquo;ll store objects you want to be serialized and deserialized
for you. Set an appropriate content-type and use the <code>#data</code> accessors:</p>
<pre class="highlight ruby"><code><span class="n">robject</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s1">'application/json'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">processor: </span><span class="s1">'MSP-430'</span><span class="p">,</span>
    <span class="ss">sensors: </span><span class="sx">%w{range binocular video}</span><span class="p">,</span>
    <span class="ss">motor: </span><span class="s2">"trolling motor"</span><span class="p">,</span>
    <span class="ss">length: </span><span class="mi">137</span><span class="o">.</span><span class="mi">16</span>
<span class="p">}</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span> <span class="c1"># serializes the Ruby hash to JSON</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="c1">#=&gt; "{\"processor\": \"MSP-430\"...</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">data</span> <span class="c1">#=&gt; {"processor" =&gt; "MSP-430",...</span>
</code></pre>

<p>Out of the box, the Ruby client supports serializing and deserializing these
content-types:</p>

<ul>
<li><code>text/plain</code>: string data only</li>
<li><code>application/json</code>: uses <code>MultiJson</code></li>
<li><code>application/x-ruby-marshal</code>: uses <code>Marshal</code> in the Ruby core</li>
<li><code>text/yaml</code>, <code>text/x-yaml</code>, <code>application/yaml</code>, <code>application/x-yaml</code>: use
<code>YAML</code> in the Ruby standard library.</li>
</ul>

<h5>Other Content Types</h5>

<p>Support for other content-types can be added: write a module with <code>dump(object)</code>
and <code>load(string)</code> methods, and configure it with the <code>Riak::Serializers[]</code>
method. For an example, note how the <code>TextPlain</code> and <code>ApplicationJSON</code>
serializers are written and configured in the <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::Serializer</code> module.</a></p>

<h3>Deleting Objects</h3>

<p>Objects can be deleted two different ways: the <code>delete</code> method on <code>RObject</code>
instances, or the <code>delete</code> method on <code>Bucket</code> instances.</p>

<p>Deleting a <code>RObject</code> you have already fetched is easy. After the <code>delete</code> method
returns, the instance will still have its data, but be frozen to prevent
further changes.</p>
<pre class="highlight ruby"><code><span class="n">robject</span><span class="p">.</span><span class="nf">delete</span>
</code></pre>

<p>Deleting from the <code>Bucket</code> without providing a <code>vclock</code> or causal context can
cause issues if the object is updated and deleted at about the same time:</p>
<pre class="highlight ruby"><code><span class="c1"># delete the object with key 'Son of Boatname' without any causal context</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">delete</span> <span class="s1">'Son of Boatname'</span>

<span class="c1"># delete the object with key 'Son of Boatname' with causal context</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">delete</span> <span class="s1">'Son of Boatname'</span><span class="p">,</span> <span class="ss">vclock: </span><span class="s1">'a85hYGBgzGDKBVIcypz/fpZz1XzPYEpkzGNluD1P4xxfFgA='</span>
</code></pre>

<h2>Content and Conflict</h2>

<p>Riak objects can have more than one value. If you have an eventually-consistent
bucket (i.e. not strongly consistent) with <code>allow_mult</code> enabled and
<code>last_write_wins</code> disabled (<a href="crdt.html">choose wisely</a>, <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">it&rsquo;s important</a>), multiple
values for a given object are common.</p>

<p>Resolving conflicts can be tricky! <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">Riak&rsquo;s CRDT implementation</a> and how the
<a href="crdt.html">Ruby client CRDT support</a> works may lead you to a better solution than
relying on client-side conflict resolution.</p>

<p>The <code>Riak::RContent</code> class handles properties of an individual value. Without
conflict, <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::RObject</code> delegates many of its apparent properties</a> to an
<code>RContent</code> instance. With conflict, attempts to access these properties will
raise a <code>Riak::Conflict</code> error.</p>
<pre class="highlight ruby"><code><span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="c1"># raises Riak::Conflict</span>
</code></pre>

<h3>Manual Conflict Resolution</h3>

<p>If a <code>Riak::RObject</code> is in conflict, you can resolve the conflict by setting its
<code>siblings</code> array to an array with one element. Ideally, you&rsquo;ll loop through the
array of siblings and accumulate a correct one.</p>

<p>In this case, assume we have objects that store a single number, and we want to
resolve them to the maximum.</p>
<pre class="highlight ruby"><code><span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>

<span class="n">max_sibling</span> <span class="o">=</span> <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span><span class="p">.</span><span class="nf">inject</span> <span class="k">do</span> <span class="o">|</span><span class="n">max_sibling</span><span class="p">,</span> <span class="n">current_sibling</span><span class="o">|</span>
    <span class="k">next</span> <span class="n">max_sibling</span> <span class="k">if</span> <span class="n">max_sibling</span><span class="p">.</span><span class="nf">data</span> <span class="o">&gt;</span> <span class="n">current_sibling</span><span class="p">.</span><span class="nf">data</span>
    <span class="k">next</span> <span class="n">current_sibling</span>
<span class="k">end</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_sibling</span><span class="p">.</span><span class="nf">dup</span><span class="p">]</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">reload</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; false</span>
</code></pre>

<h3>Conflict Resolution Callbacks</h3>

<p><code>Riak::RObject</code> also has <code>on_conflict</code> hooks. These hooks work much like manual
conflict resolution. Register them with <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::RObject.on_conflict</code></a>, and
trigger then on a conflicted object with <code>RObject#attempt_conflict_resolution</code>.</p>

<p>With the same scenario as above:</p>
<pre class="highlight ruby"><code><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">on_conflict</span> <span class="k">do</span> <span class="o">|</span><span class="n">robject</span><span class="o">|</span>
    <span class="n">max_sibling</span> <span class="o">=</span> <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span><span class="p">.</span><span class="nf">inject</span> <span class="k">do</span> <span class="o">|</span><span class="n">max_sibling</span><span class="p">,</span> <span class="n">current_sibling</span><span class="o">|</span>
        <span class="k">next</span> <span class="n">max_sibling</span> <span class="k">if</span> <span class="n">max_sibling</span><span class="p">.</span><span class="nf">data</span> <span class="o">&gt;</span> <span class="n">current_sibling</span><span class="p">.</span><span class="nf">data</span>
        <span class="k">next</span> <span class="n">current_sibling</span>
    <span class="k">end</span>

    <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_sibling</span><span class="p">.</span><span class="nf">dup</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">object</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>
<span class="n">object</span><span class="p">.</span><span class="nf">attempt_conflict_resolution</span>
<span class="n">object</span><span class="p">.</span><span class="nf">store</span>
<span class="n">object</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; false</span>
</code></pre>

<p>You can have multiple conflict resolution callbacks. If they return <code>nil</code> the
next one in the list will fire. If you want different callbacks for different
buckets, simply make the first thing they do check if the bucket is the expected
one:</p>
<pre class="highlight ruby"><code><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">on_conflict</span> <span class="k">do</span> <span class="o">|</span><span class="n">robject</span><span class="o">|</span>
  <span class="k">next</span> <span class="kp">nil</span> <span class="k">unless</span> <span class="n">robject</span><span class="p">.</span><span class="nf">bucket</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s1">'robots'</span>
  <span class="c1"># actually resolve the robot conflict</span>
<span class="k">end</span>
</code></pre>

<p>If none of the handlers resolve the conflict, the object will remain in
conflict.</p>

<h2>Working with Bucket Types</h2>

<p>Bucket types are used to configure and scope bucket behavior. If you are working
with objects scoped to bucket types, there are two APIs for handling them.</p>

<h3>2.2 Bucket-Typed Bucket API</h3>

<p>The 2.2 version of the client introduces a bucket types, buckets, and key-value
objects that know what bucket type they have.</p>

<p><code>BucketType</code> instances create <code>BucketTyped::Bucket</code> instances:</p>
<pre class="highlight ruby"><code><span class="c1"># Instantiate a Riak::BucketType from the client</span>
<span class="n">my_cool_type</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">bucket_type</span> <span class="s1">'my_cool_type'</span>

<span class="c1"># Create a Riak::BucketTyped::Bucket</span>
<span class="n">cool_pages</span> <span class="o">=</span> <span class="n">my_cool_type</span><span class="p">.</span><span class="nf">bucket</span> <span class="s1">'pages'</span>

<span class="c1"># BucketTyped::Bucket is a Bucket subclass</span>
<span class="n">cool_pages</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Riak</span><span class="o">::</span><span class="no">Bucket</span> <span class="c1">#=&gt; true</span>
<span class="n">cool_pages</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Riak</span><span class="o">::</span><span class="no">BucketTyped</span><span class="o">::</span><span class="no">Bucket</span> <span class="c1">#=&gt; true</span>
</code></pre>

<p>Bucket-typed buckets are a subclass of untyped buckets (which are handled as
default-typed buckets in Riak). Just like regular buckets, they can create
key-value objects:</p>
<pre class="highlight ruby"><code><span class="n">my_homepage</span> <span class="o">=</span> <span class="n">cool_pages</span><span class="p">.</span><span class="nf">get_or_new</span> <span class="s1">'index.html'</span>
<span class="n">under_construction</span> <span class="o">=</span> <span class="n">cool_pages</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'under_construction.gif'</span>
<span class="n">background_music</span> <span class="o">=</span> <span class="n">cool_pages</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'STAIRW~1.MID'</span>
</code></pre>

<h3>Options-hash-based Bucket Type API</h3>

<p><strong>This API is difficult to work with and requires care with passing in options.
We do not recommend using it for new development.</strong></p>

<p>2.0 and 2.1 versions of the client do not have special support for bucket
types. Key-value operations that require a bucket type must have the type
passed in with the options hash.</p>
<pre class="highlight ruby"><code><span class="n">my_homepage</span> <span class="o">=</span> <span class="n">cool_pages</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'index.html'</span><span class="p">,</span> <span class="ss">type: </span><span class="s1">'my_cool_type'</span>
<span class="n">my_homepage</span><span class="p">.</span><span class="nf">data</span> <span class="o">=</span> <span class="n">my_homepage</span><span class="p">.</span><span class="nf">data</span> <span class="o">+</span>
  <span class="s2">"&amp;lt;marquee&amp;gt;welcome to the last line of my homepage&amp;lt;/marquee&amp;gt;"</span>
<span class="n">my_homepage</span><span class="p">.</span><span class="nf">store</span> <span class="ss">type: </span><span class="s1">'my_cool_type'</span>
<span class="n">my_homepage</span><span class="p">.</span><span class="nf">reload</span> <span class="ss">type: </span><span class="s1">'my_cool_type'</span>
</code></pre>

<p>If the type is omitted from these methods, the operation will interact with the
object in the default type instead of <code>my_cool_type</code>. This is why we recommend
the easier Bucket-Typed Bucket API.</p>
</div>
</div>
<footer>
Documentation generated at 2015-02-10 20:10:04 UTC from repo version 8aa03d0d1ba72c3037119d6636c6487123d54ce2.
</footer>
</body>
</html>
