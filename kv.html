<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<title>Key-Value</title>
<link href="stylesheets/normalize.css" rel="stylesheet" type="text/css" /><link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
<script src="javascripts/all.js" type="text/javascript"></script>
</head>
<body class='kv'>
<header>
<nav>
<ul>
<li class='title'>riak-ruby-client</li>
<li><a href="./">Home</a></li>
<li><a href="kv.html">Key-Value</a></li>
<li><a href="yz.html">Search</a></li>
<li><a href="2i.html">Secondary Indexes</a></li>
<li><a href="crdt.html">CRDTs</a></li>
<li class='space'><a href="install.html">Installation</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="https://github.com/basho/riak-ruby-client">Source</a></li>
<li><a href="https://rubygems.org/gems/riak-client">Gem</a></li>
</ul>
</nav>

</header>
<div class='content'>
<h1 class='title'>Key-Value</h1>
<div id='toc'></div>
<div id='yielded'><p>Key-value operations in Riak use a few different kinds of object:</p>

<ul>
<li>A <strong>bucket type</strong> is a set of configration information used to read and write
values in Riak. Bucket types are complex and can be unintuitive, so
<a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">please read the bucket type documentation</a>.</li>
<li>A <strong>bucket</strong> is a named collection of keys. It&rsquo;s similar to a table in a SQL
database: it has a name that&rsquo;s a string, zero or more members, and members
can be quickly looked up by their key (primary key in SQL).</li>
<li>A <strong>key</strong> is a unique string name for something in a bucket. Think of them
like a SQL primary key that&rsquo;s a string.</li>
<li>A <strong>value</strong> is a large binary object that is addressed by a bucket type,
bucket, and key. It works similarly to a BLOB column in SQL. Riak objects
can have more than one value, which requires conflict resolution.</li>
</ul>

<p>For more about buckets, keys, and values, read the <a href="crdt.html">object/key operations</a>
documentation.</p>

<h2>tl;dr</h2>

<p>Get an object:</p>
<pre><code class="highlight ruby"><span class="c1"># get an object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'index.html'</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="s1">'index.html'</span><span class="p">]</span>

<span class="c1"># get or create an object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">get_or_new</span> <span class="s1">'index.html'</span>

<span class="c1"># create a new object</span>
<span class="n">object</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'index.html'</span>

<span class="c1"># change the object's data and save</span>
<span class="n">object</span><span class="p">.</span><span class="nf">raw_data</span> <span class="o">=</span> <span class="s2">"&lt;html&gt;&lt;body&gt;Hello, world!&lt;/body&gt;&lt;/html&gt;"</span>
<span class="n">object</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s2">"text/html"</span>
<span class="n">object</span><span class="p">.</span><span class="nf">store</span>

<span class="c1"># reload an object you already have the vclock of</span>
<span class="n">object</span><span class="p">.</span><span class="nf">reload</span>

<span class="c1"># reload an object without the vclock</span>
<span class="n">object</span><span class="p">.</span><span class="nf">reload</span> <span class="ss">:force</span> <span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre>

<h2>Objects</h2>

<p>Riak&rsquo;s key-value interface maniuplates objects. You can think of an object as
a tuple:</p>
<pre><code class="highlight ruby">  <span class="p">{</span><span class="n">bucket</span> <span class="n">type</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">values</span><span class="p">}</span>
</code></pre>

<p>A bucket type and bucket identify a collection of objects, and the set of
bucket type, bucket, and key identify a single object.</p>

<p>In the Ruby client, a Riak object is represented by a <code>Riak::RObject</code> instance.</p>
<pre><code class="highlight ruby"><span class="n">robject</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">[</span><span class="s1">'S. S. Boatname'</span><span class="p">]</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">class</span> <span class="c1">#=&gt; Riak::RObject</span>
</code></pre>

<h3>Creating Objects</h3>

<p>You have a few choices when insantiating an object.</p>

<p>Given a bucket, you can use the <code>RObject</code> constructor to create a new object:</p>
<pre><code class="highlight ruby"><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="s1">'Son of Boatname'</span>
</code></pre>

<p>If you use the <code>Bucket#new</code> method, the <code>RObject</code> is created with a
<code>content_type</code> of <code>application/json</code> for you:</p>
<pre><code class="highlight ruby"><span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'Son of Boatname'</span>
</code></pre>

<p>If you want Riak to pick a key for an object for you, create one without
specifying a key:</p>
<pre><code class="highlight ruby"><span class="c1"># these both work</span>
<span class="n">robject</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">new</span> <span class="n">bucket</span><span class="p">,</span> <span class="kp">nil</span>
<span class="n">robject</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">key</span> <span class="c1">#=&gt; "GB8fW6DDZtXogK19OLmaJf247DN"</span>
</code></pre>

<h3>Loading Objects</h3>

<p>You can load an object if you know its key. If loading the object fails, this
will raise a <code>Riak::FailedRequest</code> error with the <code>not_found?</code> flag set.</p>
<pre><code class="highlight ruby"><span class="n">bucket</span><span class="p">[</span><span class="s1">'S. S. Boatname'</span><span class="p">]</span>
<span class="n">bucket</span><span class="p">.</span><span class="nf">get</span> <span class="s1">'S.S. Boatname'</span>
</code></pre>

<p>If you want to load or create an object with a given key, you can use
<code>Bucket#get_or_new</code> to do it:</p>
<pre><code class="highlight ruby"><span class="n">bucket</span><span class="p">.</span><span class="nf">get_or_new</span> <span class="s1">'Revenge of Boatname'</span>
</code></pre>

<h3>Manipulating and Storing Objects</h3>

<h4>Raw Data, No Serialization</h4>

<p>Use the <code>RObject#raw_data</code> accessors to manipulate the raw blob/string that
represents the value of a Riak object. The client will not transform or parse
this data.</p>
<pre><code class="highlight ruby"><span class="n">robject</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s1">'image/jpeg'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span> <span class="s1">'cat.jpg'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>
</code></pre>

<h4>Serializing and Deserializing Data</h4>

<p>Frequently, you&rsquo;ll store objects you want to be serialized and deserialized
for you. Set an appropriate content-type and use the <code>#data</code> accessors:</p>
<pre><code class="highlight ruby"><span class="n">robject</span><span class="p">.</span><span class="nf">content_type</span> <span class="o">=</span> <span class="s1">'application/json'</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">processor: </span><span class="s1">'MSP-430'</span><span class="p">,</span>
    <span class="ss">sensors: </span><span class="sx">%w{range binocular video}</span><span class="p">,</span>
    <span class="ss">motor: </span><span class="s2">"trolling motor"</span><span class="p">,</span>
    <span class="ss">length: </span><span class="mi">137</span><span class="o">.</span><span class="mi">16</span>
<span class="p">}</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span> <span class="c1"># serializes the Ruby hash to JSON</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="c1">#=&gt; "{\"processor\": \"MSP-430\"...</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">data</span> <span class="c1">#=&gt; {"processor" =&gt; "MSP-430",...</span>
</code></pre>

<p>Out of the box, the Ruby client supports serializing and deserializing these
content-types:</p>

<ul>
<li><code>text/plain</code>: string data only</li>
<li><code>application/json</code>: uses <code>MultiJson</code></li>
<li><code>application/x-ruby-marshal</code>: uses <code>Marshal</code> in the Ruby core</li>
<li><code>text/yaml</code>, <code>text/x-yaml</code>, <code>application/yaml</code>, <code>application/x-yaml</code>: use
<code>YAML</code> in the Ruby standard library.</li>
</ul>

<h5>Other Content Types</h5>

<p>Support for other content-types can be added: write a module with <code>dump(object)</code>
and <code>load(string)</code> methods, and configure it with the <code>Riak::Serializers[]</code>
method. For an example, note how the <code>TextPlain</code> and <code>ApplicationJSON</code>
serializers are written and configured in the <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::Serializer</code> module.</a></p>

<h2>Content and Conflict</h2>

<p>Riak objects can have more than one value. If you have an eventually-consistent
bucket (i.e. not strongly consistent) with <code>allow_mult</code> enabled and
<code>last_write_wins</code> disabled (<a href="crdt.html">choose wisely</a>, <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">it&rsquo;s important</a>), multiple
values for a given object are common.</p>

<p>Resolving conflicts can be tricky! <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict">Riak&rsquo;s CRDT implementation</a> and how the
<a href="crdt.html">Ruby client CRDT support</a> works may lead you to a better solution than
relying on client-side conflict resolution.</p>

<p>The <code>Riak::RContent</code> class handles properties of an individual value. Without
conflict, <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::RObject</code> delegates many of its apparent properties</a> to an
<code>RContent</code> instance. With conflict, attempts to access these properties will
raise a <code>Riak::Conflict</code> error.</p>
<pre><code class="highlight ruby"><span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">raw_data</span> <span class="c1"># raises Riak::Conflict</span>
</code></pre>

<h3>Manual Conflict Resolution</h3>

<p>If a <code>Riak::RObject</code> is in conflict, you can resolve the conflict by setting its
<code>siblings</code> array to an array with one element. Ideally, you&rsquo;ll loop through the
array of siblings and accumulate a correct one.</p>

<p>In this case, assume we have objects that store a single number, and we want to
resolve them to the maximum.</p>
<pre><code class="highlight ruby"><span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>

<span class="n">max_sibling</span> <span class="o">=</span> <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span><span class="p">.</span><span class="nf">inject</span> <span class="k">do</span> <span class="o">|</span><span class="n">max_sibling</span><span class="p">,</span> <span class="n">current_sibling</span><span class="o">|</span>
    <span class="k">next</span> <span class="n">max_sibling</span> <span class="k">if</span> <span class="n">max_sibling</span><span class="p">.</span><span class="nf">data</span> <span class="o">&gt;</span> <span class="n">current_sibling</span><span class="p">.</span><span class="nf">data</span>
    <span class="k">next</span> <span class="n">current_sibling</span>
<span class="k">end</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_sibling</span><span class="p">.</span><span class="nf">dup</span><span class="p">]</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">store</span>

<span class="n">robject</span><span class="p">.</span><span class="nf">reload</span>
<span class="n">robject</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; false</span>
</code></pre>

<h3>Conflict Resolution Callbacks</h3>

<p><code>Riak::RObject</code> also has <code>on_conflict</code> hooks. These hooks work much like manual
conflict resolution. Register them with <a href="http://www.rubydoc.info/gems/riak-client/Riak/RObject.on_conflict"><code>Riak::RObject.on_conflict</code></a>, and
trigger then on a conflicted object with <code>RObject#attempt_conflict_resolution</code>.</p>

<p>With the same scenario as above:</p>
<pre><code class="highlight ruby"><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">on_conflict</span> <span class="k">do</span> <span class="o">|</span><span class="n">robject</span><span class="o">|</span>
    <span class="n">max_sibling</span> <span class="o">=</span> <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span><span class="p">.</span><span class="nf">inject</span> <span class="k">do</span> <span class="o">|</span><span class="n">max_sibling</span><span class="p">,</span> <span class="n">current_sibling</span><span class="o">|</span>
        <span class="k">next</span> <span class="n">max_sibling</span> <span class="k">if</span> <span class="n">max_sibling</span><span class="p">.</span><span class="nf">data</span> <span class="o">&gt;</span> <span class="n">current_sibling</span><span class="p">.</span><span class="nf">data</span>
        <span class="k">next</span> <span class="n">current_sibling</span>
    <span class="k">end</span>

    <span class="n">robject</span><span class="p">.</span><span class="nf">siblings</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_sibling</span><span class="p">.</span><span class="nf">dup</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">object</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; true</span>
<span class="n">object</span><span class="p">.</span><span class="nf">attempt_conflict_resolution</span>
<span class="n">object</span><span class="p">.</span><span class="nf">store</span>
<span class="n">object</span><span class="p">.</span><span class="nf">conflict?</span> <span class="c1">#=&gt; false</span>
</code></pre>

<p>You can have multiple conflict resolution callbacks. If they return <code>nil</code> the
next one in the list will fire. If you want different callbacks for different
buckets, simply make the first thing they do check if the bucket is the expected
one:</p>
<pre><code class="highlight ruby"><span class="no">Riak</span><span class="o">::</span><span class="no">RObject</span><span class="p">.</span><span class="nf">on_conflict</span> <span class="k">do</span> <span class="o">|</span><span class="n">robject</span><span class="o">|</span>
  <span class="k">next</span> <span class="kp">nil</span> <span class="k">unless</span> <span class="n">robject</span><span class="p">.</span><span class="nf">bucket</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s1">'robots'</span>
  <span class="c1"># actually resolve the robot conflict</span>
<span class="k">end</span>
</code></pre>

<p>If none of the handlers resolve the conflict, the object will remain in
conflict.</p>
</div>
</div>
<footer>
Documentation generated at 2014-10-21 19:32:45 UTC from repo version 3142889c830acd3e7724822144cfe9b8cda6948e.
</footer>
</body>
</html>
