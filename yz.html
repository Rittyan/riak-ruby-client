<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
<title>Search</title>
<link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
<script src="javascripts/all.js" type="text/javascript"></script>
</head>
<body class='yz'>
<header>
<nav>
<ul>
<li class='title'>riak-ruby-client</li>
<li><a href="./">Home</a></li>
<li><a href="kv.html">Key-Value</a></li>
<li><a href="yz.html">Search</a></li>
<li><a href="2i.html">Secondary Indexes</a></li>
<li><a href="crdt.html">CRDTs</a></li>
<li><a href="bucket_types.html">Bucket Types</a></li>
<li><a href="bucket_props.html">Bucket Properties</a></li>
<li><a href="rspecs.html">Testing</a></li>
<li class='space'><a href="install.html">Installation</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="https://github.com/basho/riak-ruby-client">Source</a></li>
<li><a href="https://rubygems.org/gems/riak-client">Gem</a></li>
</ul>
</nav>

</header>
<div class='content'>
<h1 class='title'>Search</h1>
<div id='toc'></div>
<div id='yielded'><p>Riak 2 features two search systems. New in Riak 2 is &ldquo;Riak Search 2.0,&rdquo; which was
developed under the codename &ldquo;Yokozuna.&rdquo; It uses <a href="https://lucene.apache.org/core/3_6_0/queryparsersyntax.html">Solr</a> for indexing and
querying, and <code>riak-core</code> for distributing and sharding indexes.</p>

<p>This document covers using Riak Search 2.0 with the Ruby client. See the full
<a href="http://docs.basho.com/riak/latest/dev/using/search/">Riak Search documentation</a> for more about working with search itself.</p>

<h2>tl;dr</h2>

<p>This documentation assumes you have a <code>yokozuna</code> bucket type defined.</p>
<pre class="highlight ruby"><code><span class="nb">require</span> <span class="s1">'riak'</span>
<span class="n">client</span> <span class="o">=</span> <span class="no">Riak</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span>
<span class="n">bucket</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">bucket</span> <span class="s1">'pizzas'</span>

<span class="c1"># Create an index</span>
<span class="n">client</span><span class="p">.</span><span class="nf">create_search_index</span> <span class="s1">'pizzas'</span>
<span class="c1"># Add the new index to a typed bucket. Setting the index on the bucket</span>
<span class="c1"># may fail until the index creation has propagated.</span>
<span class="n">client</span><span class="p">.</span><span class="nf">set_bucket_props</span> <span class="n">bucket</span><span class="p">,</span> <span class="p">{</span><span class="ss">search_index: </span><span class="s1">'pizzas'</span><span class="p">},</span> <span class="s1">'yokozuna'</span>

<span class="c1"># Store records</span>
<span class="n">meat</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'meat'</span>
<span class="n">meat</span><span class="p">.</span><span class="nf">data</span> <span class="o">=</span> <span class="p">{</span><span class="ss">toppings_ss: </span><span class="sx">%w{pepperoni ham sausage}</span><span class="p">}</span>
<span class="n">meat</span><span class="p">.</span><span class="nf">store</span> <span class="ss">type: </span><span class="s1">'yokozuna'</span>

<span class="n">hawaiian</span> <span class="o">=</span> <span class="n">bucket</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'hawaiian'</span>
<span class="n">hawaiian</span><span class="p">.</span><span class="nf">data</span> <span class="o">=</span> <span class="p">{</span><span class="ss">toppings_ss: </span><span class="sx">%w{ham pineapple}</span><span class="p">}</span>
<span class="n">hawaiian</span><span class="p">.</span><span class="nf">store</span> <span class="ss">type: </span><span class="s1">'yokozuna'</span>

<span class="c1"># Search the pizzas index for hashes that have a "ham" entry in the</span>
<span class="c1"># toppings_ss array</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s1">'pizzas'</span><span class="p">,</span> <span class="s1">'toppings_ss:ham'</span><span class="p">)</span> <span class="c1"># Returns a results hash</span>
<span class="n">result</span><span class="p">[</span><span class="s1">'num_found'</span><span class="p">]</span> <span class="c1"># total number of results</span>
<span class="n">result</span><span class="p">[</span><span class="s1">'docs'</span><span class="p">]</span>      <span class="c1"># the list of indexed documents</span>
</code></pre>

<h2>Queries and Results</h2>

<p>The Ruby client allows searching on an index level:
<code>ruby
results = client.search &#39;index_name&#39;, &#39;search query&#39;
</code></p>

<p>You can use normal <a href="https://lucene.apache.org/core/3_6_0/queryparsersyntax.html">Lucene query syntax</a> for searching:</p>
<pre class="highlight ruby"><code><span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s2">"famous"</span><span class="p">,</span> <span class="s2">"name_s:Lion*"</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s2">"famous"</span><span class="p">,</span> <span class="s2">"age_i:[30 TO *]"</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s2">"famous"</span><span class="p">,</span> <span class="s2">"leader_b:true AND age_i:[30 TO *]"</span><span class="p">)</span>
</code></pre>

<p>The search method takes several optional parameters too:</p>
<pre class="highlight ruby"><code><span class="n">results</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">search</span><span class="p">(</span><span class="s1">'famous'</span><span class="p">,</span> <span class="s2">"Olive"</span><span class="p">,</span> <span class="p">{</span><span class="ss">sort: </span><span class="s2">"age_i asc"</span><span class="p">,</span> <span class="ss">rows: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">df: </span><span class="s1">'dog_ss'</span><span class="p">})</span>
</code></pre>

<p>The results object returned from the search has useful information:</p>
<pre class="highlight ruby"><code><span class="n">results</span><span class="p">[</span><span class="s1">'numFound'</span><span class="p">]</span> <span class="c1">#=&gt; number of results found</span>
<span class="n">results</span><span class="p">[</span><span class="s1">'docs'</span><span class="p">]</span> <span class="c1">#=&gt; array of results</span>

<span class="n">doc</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">'docs'</span><span class="p">].</span><span class="nf">first</span>
<span class="n">doc</span><span class="p">[</span><span class="s1">'_yz_rb'</span><span class="p">]</span> <span class="c1">#=&gt; bucket of document</span>
<span class="n">doc</span><span class="p">[</span><span class="s1">'_yz_rk'</span><span class="p">]</span> <span class="c1">#=&gt; key of document</span>
</code></pre>

<h2>Indexes</h2>

<p>Indexes are what actually connects search terms to documents. They can be created,
attached to buckets, and inspected from the Ruby client:</p>
<pre class="highlight ruby"><code><span class="c1"># Creating an index requires the name, and can specify a schema, and an</span>
<span class="c1"># n-value for index replication too.</span>
<span class="n">client</span><span class="p">.</span><span class="nf">create_search_index</span> <span class="s1">'index_name'</span>
<span class="n">client</span><span class="p">.</span><span class="nf">create_search_index</span> <span class="s1">'index_name'</span><span class="p">,</span> <span class="s1">'schema_name'</span><span class="p">,</span> <span class="n">n_value</span>

<span class="n">idx</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">get_search_index</span> <span class="s1">'index_name'</span>
<span class="c1"># idx is an index object, with name, schema, and n_val accessors</span>

<span class="n">client</span><span class="p">.</span><span class="nf">get_search_index</span> <span class="s1">'not_an_index'</span> <span class="c1"># raises Riak::ProtobuffsFailedRequest</span>

<span class="c1"># Attach the index_name to writes to bucket with the yokozuna bucket type.</span>
<span class="n">client</span><span class="p">.</span><span class="nf">set_bucket_props</span> <span class="n">bucket</span><span class="p">,</span> <span class="p">{</span><span class="ss">search_index: </span><span class="s1">'index_name'</span><span class="p">},</span> <span class="s1">'yokozuna'</span>
</code></pre>

<h2>Schemas</h2>

<p>Schemas explain to Solr how fields should be indexed. They can be created and
read with the Ruby client:</p>
<pre class="highlight ruby"><code><span class="n">schema_content</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span> <span class="s1">'schema.xml'</span>
<span class="n">client</span><span class="p">.</span><span class="nf">create_search_schema</span> <span class="s1">'schema_for_cool_cats'</span><span class="p">,</span> <span class="n">schema_content</span>

<span class="n">schema_response</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">get_search_schema</span> <span class="s1">'schema_for_cool_cats'</span>
<span class="n">schema_response</span><span class="p">.</span><span class="nf">name</span> <span class="c1">#=&gt; "schema_for_cool_cats"</span>
<span class="n">schema_response</span><span class="p">.</span><span class="nf">content</span> <span class="c1">#=&gt; "&lt;?xml version..."</span>
</code></pre>
</div>
</div>
<footer>
Documentation generated at 2015-02-10 20:10:04 UTC from repo version 8aa03d0d1ba72c3037119d6636c6487123d54ce2.
</footer>
</body>
</html>
